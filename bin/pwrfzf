#!/usr/bin/env bash
# vim:filetype=zsh:shiftwidth=2:softtabstop=2:expandtab:foldmethod=marker:foldmarker=###{{{,###}}}

# PWRFZF - Powerful Gentoo Package Manager with FZF
# A comprehensive interactive package and repository management tool for Gentoo Linux

# Re-execute the script in bash if not running in bash or zsh
if [ -z "$BASH_VERSION" ] && [ -z "$ZSH_VERSION" ]; then
  exec bash "$0" "$@"
fi

# Check and set options for bash
if [ -n "$BASH_VERSION" ]; then
  shopt -s lastpipe
  export SHELL=bash
fi

# Define constants and default values
PWRFZF_VERSION="2.0"
PROG="pwrfzf"
AUTHOR="spikyatlinux"
REPO="https://github.com/${AUTHOR}/${PROG}"

# Configuration directories
PWRFZF_CACHE_DIR="${XDG_CACHE_HOME:-${HOME}/.cache}/${PROG}"
PWRFZF_CONFIG_DIR="${XDG_CONFIG_HOME:-${HOME}/.config}/${PROG}"
PWRFZF_CONFIG_FILE="${PWRFZF_CONFIG_DIR}/pwrfzf-config"
PWRFZF_HISTORY="${PWRFZF_CACHE_DIR}/history"
PWRFZF_INSTALL_LIST="${PWRFZF_CACHE_DIR}/install_list"
PWRFZF_LAYOUT_FILE="${PWRFZF_CACHE_DIR}/layout"

# Default configuration variables
PWRFZF_PREVIEW_WINDOW="${PWRFZF_PREVIEW_WINDOW:-right,60%,border-left}"
PWRFZF_SHOW_INSTALLED="${PWRFZF_SHOW_INSTALLED:-true}"
PWRFZF_AUTO_SYNC="${PWRFZF_AUTO_SYNC:-false}"
PWRFZF_CONFIRM_ACTIONS="${PWRFZF_CONFIRM_ACTIONS:-true}"
PWRFZF_MAX_PREVIEW_LINES="${PWRFZF_MAX_PREVIEW_LINES:-50}"
PWRFZF_LOGGING="${PWRFZF_LOGGING:-false}"

# Global variables
declare -g PWRFZF_MODE="packages"
declare -g PWRFZF_LAYOUT="default"
declare -g PRIV_ESC
declare -g EMERGE_CMD
declare -gA pwrfzf_color pwrfzf_fx

# Portage configuration types
declare -gA PORTAGE_CONFIG_TYPES=(
    [accept_keywords]="Keywords (~amd64, etc.)"
    [use]="USE flags"
    [mask]="Masked packages" 
    [unmask]="Unmasked packages"
    [env]="Environment settings"
    [sets]="Package sets"
)

# Initialize script
function _pwrfzf_init() {
    _check_dependencies
    _create_directories
    _load_config
    _validate_config
    _setup_logging
    _set_colors
    _set_fx
    _find_privilege_escalator
    _find_emerge
    _load_emerge_default_opts
    _load_layout
}

# Setup logging based on configuration
function _setup_logging() {
    if [[ "${PWRFZF_LOGGING}" == "true" ]]; then
        local log_file="${PWRFZF_CONFIG_DIR}/pwrfzf.log"
        # Create log directory if it doesn't exist
        mkdir -p "$(dirname "$log_file")"
        
        # Function to strip ANSI color codes
        function _strip_ansi() {
            sed -E 's/\x1B\[[0-9;]*[mGK]//g'
        }
        
        # Redirect stdout and stderr to log file with ANSI stripping
        exec > >(tee >(_strip_ansi >> "$log_file"))
        exec 2> >(tee >(_strip_ansi >> "$log_file") >&2)
        
        _pwrfzf_verbose "Logging enabled: $log_file"
    fi
}

# Check for required dependencies
function _check_dependencies() {
    local deps=("fzf" "eix" "qlist" "qsearch")
    local missing=()
    
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            missing+=("$dep")
        fi
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        _pwrfzf_error "Missing dependencies: ${missing[*]}"
        _pwrfzf_warning "Install with: emerge --ask ${missing[*]}"
        exit 1
    fi
}

# Create necessary directories
function _create_directories() {
    local dirs=("$PWRFZF_CACHE_DIR" "$PWRFZF_CONFIG_DIR")
    
    for dir in "${dirs[@]}"; do
        if [[ ! -d "$dir" ]]; then
            mkdir -p "$dir" 2>/dev/null || {
                _pwrfzf_error "Failed to create directory: $dir"
                exit 1
            }
        fi
    done
    
    # Create files if they don't exist
    touch "$PWRFZF_HISTORY" "$PWRFZF_INSTALL_LIST" 2>/dev/null
}

# Load configuration file
function _load_config() {
    if [[ -f "$PWRFZF_CONFIG_FILE" ]]; then
        source "$PWRFZF_CONFIG_FILE" 2>/dev/null || {
            _pwrfzf_warning "Error loading config file. Using defaults."
        }
    else
        _create_default_config
    fi
}

# Validate configuration after loading
function _validate_config() {
    # Validate PRIV_ESC if set
    if [[ -n "$PRIV_ESC" ]]; then
        if [[ "$PRIV_ESC" != "sudo" && "$PRIV_ESC" != "doas" && "$PRIV_ESC" != "" ]]; then
            _pwrfzf_warning "Invalid PRIV_ESC value: '$PRIV_ESC'. Using auto-detection."
            unset PRIV_ESC
        elif [[ -n "$PRIV_ESC" ]] && ! command -v "$PRIV_ESC" >/dev/null 2>&1; then
            _pwrfzf_warning "Configured PRIV_ESC '$PRIV_ESC' not found in PATH. Using auto-detection."
            unset PRIV_ESC
        fi
    fi
    
    # Validate logging
    if [[ "$PWRFZF_LOGGING" != "true" && "$PWRFZF_LOGGING" != "false" ]]; then
        _pwrfzf_warning "Invalid PWRFZF_LOGGING value: '$PWRFZF_LOGGING'. Using default: false"
        PWRFZF_LOGGING="false"
    fi
}

# Create default configuration file
function _create_default_config() {
    cat > "$PWRFZF_CONFIG_FILE" << 'EOF'
# PWRFZF Configuration File
# Colors and display
NO_COLOR=false
NO_FX=false

# Behavior
PWRFZF_SHOW_INSTALLED=true
PWRFZF_AUTO_SYNC=false
PWRFZF_CONFIRM_ACTIONS=true
PWRFZF_MAX_PREVIEW_LINES=50
PWRFZF_LOGGING=true

# Emerge behavior
# Set to true to use fallback emerge options
PWRFZF_USE_DEFAULT_EMERGE_OPTS=false
# Additional environment variables
# export EMERGE_DEFAULT_OPTS="$EMERGE_DEFAULT_OPTS --verbose"
# export NO_COLOR=false
#
# Layout
PWRFZF_PREVIEW_WINDOW="right,60%,border-left"

# Privilege escalation (sudo/doas/empty for root)
PRIV_ESC="sudo"
# PRIV_ESC="doas"
# PRIV_ESC=""  # for root
EOF
    _pwrfzf_verbose "Created default configuration: $PWRFZF_CONFIG_FILE"
}

# Find privilege escalator (sudo/doas)
function _find_privilege_escalator() {
    # Check if PRIV_ESC is already set in config
    if [[ -n "$PRIV_ESC" ]]; then
        _pwrfzf_verbose "Using configured privilege escalator: $PRIV_ESC"
        return
    fi
    
    if [[ $EUID -eq 0 ]]; then
        PRIV_ESC=""
        _pwrfzf_verbose "Running as root, no privilege escalation needed"
        return
    fi
    
    # Auto-detect if not configured
    if command -v sudo >/dev/null 2>&1; then
        PRIV_ESC="sudo"
        _pwrfzf_verbose "Auto-detected sudo as privilege escalator"
    elif command -v doas >/dev/null 2>&1; then
        PRIV_ESC="doas"
        _pwrfzf_verbose "Auto-detected doas as privilege escalator"
    else
        _pwrfzf_error "Neither sudo nor doas found. Install one or run as root."
        _pwrfzf_error "You can set PRIV_ESC in $PWRFZF_CONFIG_FILE"
        exit 1
    fi
}

# Set color theme and color definitions
function _set_colors() {
    if [[ "${NO_COLOR}" != "true" && "${NO_COLOR}" != "1" ]]; then
        pwrfzf_colortheme="hl:italic:#FFFF00,hl+:bold:underline:#FF0000"
        pwrfzf_colortheme+=",fg:#98A0C5,fg+:bold:underline:#FFFFFF"
        pwrfzf_colortheme+=",bg:#13172A,bg+:#0F1222"
        pwrfzf_colortheme+=",border:#75A2F7,label:bold:#75A2F7"
        pwrfzf_colortheme+=",preview-fg:bold:#C0CAF5,preview-bg:#0F1222"
        pwrfzf_colortheme+=",marker:#00FF00,gutter:#0F1222,pointer:#FF0000"
        pwrfzf_colortheme+=",query:#FF0000,info:italic:#98A0C5,spinner:#00FFFF,header:italic:#75A2F7"
        COLOR_WHEN="always"
        pwrfzf_color=(
            [Reset]='\x1B[0m'
            [Bold]='\x1B[1m'
            [Italic]='\x1B[3m'
            [Underline]='\x1B[4m'
            [Black]='\x1B[38;5;0m'
            [Gray]='\x1B[38;5;245m'
            [White]='\x1B[38;5;15m'
            [Red]='\x1B[38;5;196m'
            [Green]='\x1B[38;5;46m'
            [Yellow]='\x1B[38;5;190m'
            [Blue]='\x1B[38;5;33m'
            [Cyan]='\x1B[38;5;87m'
            [BG_Black]='\x1B[48;5;0m'
            [BG_Gray]='\x1B[48;5;245m'
            [BG_White]='\x1B[48;5;15m'
            [BG_Red]='\x1B[48;5;196m'
            [BG_Green]='\x1B[48;5;46m'
            [BG_Yellow]='\x1B[48;5;190m'
            [BG_Blue]='\x1B[48;5;33m'
            [BG_Cyan]='\x1B[48;5;87m'
        )
    else
        pwrfzf_colortheme="fg:#FFFFFF"
        COLOR_WHEN="never"
    fi
}

# Set terminal effects if NO_FX is not set
function _set_fx() {
    if [[ -z ${NO_FX} ]]; then
        pwrfzf_fx=(
            [Save_Title]='\x1B[22;0t'
            [Restore_Title]='\x1B[23;0t'
        )
    fi
}

# Find the emerge command
function _find_emerge() {
    if [[ -z $EMERGE_CMD ]]; then
        if [[ $EUID -eq 0 ]]; then
            EMERGE_CMD="emerge"
        else
            EMERGE_CMD="${PRIV_ESC} emerge"
        fi
    fi
}

# Then add a function to load EMERGE_DEFAULT_OPTS properly
function _load_emerge_default_opts() {
    # First try to get EMERGE_DEFAULT_OPTS from current environment
    if [[ -n "$EMERGE_DEFAULT_OPTS" ]]; then
        _pwrfzf_verbose "Using EMERGE_DEFAULT_OPTS from environment: $EMERGE_DEFAULT_OPTS"
        return
    fi
    
    # Try to source make.conf and extract EMERGE_DEFAULT_OPTS
    local make_conf="/etc/portage/make.conf"
    if [[ -f "$make_conf" ]]; then
        # Safely source make.conf and capture EMERGE_DEFAULT_OPTS
        local sourced_opts
        sourced_opts=$(source "$make_conf" 2>/dev/null; echo "$EMERGE_DEFAULT_OPTS")
        
        if [[ -n "$sourced_opts" ]]; then
            EMERGE_DEFAULT_OPTS="$sourced_opts"
            _pwrfzf_verbose "Loaded EMERGE_DEFAULT_OPTS from $make_conf: $EMERGE_DEFAULT_OPTS"
            return
        fi
    fi
    
    # Check make.conf.d directory
    local make_conf_dir="/etc/portage/make.conf.d"
    if [[ -d "$make_conf_dir" ]]; then
        for conf_file in "$make_conf_dir"/*.conf; do
            [[ -f "$conf_file" ]] || continue
            local sourced_opts
            sourced_opts=$(source "$conf_file" 2>/dev/null; echo "$EMERGE_DEFAULT_OPTS")
            if [[ -n "$sourced_opts" ]]; then
                EMERGE_DEFAULT_OPTS="$sourced_opts"
                _pwrfzf_verbose "Loaded EMERGE_DEFAULT_OPTS from $conf_file: $EMERGE_DEFAULT_OPTS"
                return
            fi
        done
    fi

    # Only use fallback if explicitly enabled in config
    if [[ "${PWRFZF_USE_DEFAULT_EMERGE_OPTS:-false}" == "true" ]]; then
        EMERGE_DEFAULT_OPTS="--quiet-build=y --keep-going"
        _pwrfzf_verbose "Using fallback EMERGE_DEFAULT_OPTS: $EMERGE_DEFAULT_OPTS"
    else
        _pwrfzf_verbose "No EMERGE_DEFAULT_OPTS found and fallback disabled"
    fi

}

# Load layout from file
function _load_layout() {
    if [[ -f "$PWRFZF_LAYOUT_FILE" ]]; then
        PWRFZF_LAYOUT=$(<"$PWRFZF_LAYOUT_FILE")
    fi
}

# Save layout to file
function _save_layout() {
    echo "$PWRFZF_LAYOUT" > "$PWRFZF_LAYOUT_FILE"
}

# Functions to print error, warning, and verbose messages
function _pwrfzf_error() {
    printf "${pwrfzf_color[Bold]}${pwrfzf_color[BG_Red]}${pwrfzf_color[White]} ERROR ${pwrfzf_color[Reset]}:\t${pwrfzf_color[Italic]}${pwrfzf_color[Red]}%s${pwrfzf_color[Reset]}\n" "$@" >&2
}

function _pwrfzf_warning() {
    printf "${pwrfzf_color[Bold]}${pwrfzf_color[BG_Yellow]}${pwrfzf_color[Black]} WARNING ${pwrfzf_color[Reset]}:\t${pwrfzf_color[Italic]}${pwrfzf_color[Yellow]}%s${pwrfzf_color[Reset]}\n" "$@" >&2
}

function _pwrfzf_verbose() {
    printf "${pwrfzf_color[Bold]}${pwrfzf_color[BG_Blue]}${pwrfzf_color[Yellow]} VERBOSE ${pwrfzf_color[Reset]}:\t${pwrfzf_color[Italic]}${pwrfzf_color[Cyan]}%s${pwrfzf_color[Reset]}\n" "$@"
}

function _pwrfzf_success() {
    printf "${pwrfzf_color[Bold]}${pwrfzf_color[BG_Green]}${pwrfzf_color[Black]} SUCCESS ${pwrfzf_color[Reset]}:\t${pwrfzf_color[Italic]}${pwrfzf_color[Green]}%s${pwrfzf_color[Reset]}\n" "$@"
}

# Display keybindings
function _pwrfzf_keys() {
    cat <<EOF
KEYBINDINGS:
                     TAB : Select
               Shift-TAB : Unselect
                  Ctrl-d : Deselect all
                  Ctrl-i : Add to install list
                  Ctrl-r : Uninstall selected
                  Ctrl-w : Update all world packages
                  Ctrl-z : Run preserved rebuild
                  Ctrl-s : Sync repositories
                  Ctrl-n : History next
                  Ctrl-b : History previous (back)
                  Ctrl-/ : Change layout
                  Ctrl-v : Hide/show preview
                  Ctrl-o : Open Portage config manager
                    HOME : Top
                     END : Bottom
                  PAGEUP : Scroll one page up
                PAGEDOWN : Scroll one page down
                  Ctrl-l : Clear query
           Alt-backspace : Clear query
                Alt-left : Delete word
                 Ctrl-h  : Show help
                       ? : Show keybindings
                  Ctrl-q : Exit
                     ESC : Exit
EOF
}

# Display help message
function _pwrfzf_help() {
    cat >&2 <<EOF
NAME:
  $PROG
DESCRIPTION:
  Search, install, remove packages from the Gentoo overlays interactively with fzf
USAGE:
  $PROG [options] [search query]
  $PROG [-V|--version] [-k|--keybindings] [-h|--help] [search query]
OPTIONS:
  -h                   Show the help menu
  --help               Show the extended help menu of $PROG
  -k, --keybindings    List keybindings for $PROG
  -V, --version        Show version of $PROG
  -c, --config         Manage Portage configuration
  --preserved-rebuild  Run preserved rebuild
  --sync               Sync repositories
  For more information, visit the repository at $REPO
EOF
}

# Display extended help message
function _pwrfzf_help_full() {
    _pwrfzf_help
    cat >&2 <<EOF
EXAMPLES:
  $ $PROG        : Run $PROG with no search query
  $ $PROG fzf    : Search for 'fzf' with $PROG
  $ $PROG -c     : Manage Portage configuration
  $ $PROG --preserved-rebuild : Run preserved rebuild
  $ $PROG --sync : Sync repositories
$(_pwrfzf_keys)
For more information, check out the pwrfzf README
https://github.com/spikyatlinux/pwrfzf/README.md
EOF
}

# Display version
function _pwrfzf_version() {
    echo "${PROG}: ${PWRFZF_VERSION}"
}

# Emerge list function
function __emerge_list() {
    qsearch --all | sort -r | grep -E "${1:-.*}"
}

# Enhanced preview function
function __fzf_preview() {
    local package_name=$(echo "$1" | cut -d':' -f1)
    
    if [[ -z "$package_name" ]]; then
        return
    fi
    
    {
        # Package information
        eix "$package_name" 2>/dev/null
        
        echo
        echo "════════════════════════════════════════════════════════════════════════════════"
        echo "PORTAGE CONFIGURATION:"
        
        # Check Portage configuration files
        for config_type in accept_keywords env mask unmask use; do
            local config_file="/etc/portage/package.$config_type"
            if [[ -f "$config_file" ]] || [[ -d "$config_file" ]]; then
                local config_content
                config_content=$(grep -r "$package_name" "$config_file" 2>/dev/null | head -5)
                if [[ -n "$config_content" ]]; then
                    echo
                    echo "package.$config_type:"
                    echo "$config_content"
                fi
            fi
        done
        
        echo
        echo "════════════════════════════════════════════════════════════════════════════════"
        echo "INSTALLED FILES:"
        qlist "$package_name" 2>/dev/null | head -20
    } 2>/dev/null
}

# Portage configuration management
function _portage_config_manager() {
    while true; do
        local config_type
        config_type=$(echo -e "make.conf\naccept_keywords\nuse\nmask\nunmask\nenv\nsets" | fzf \
            --bind 'enter:accept' \
            --bind 'esc:abort' \
            --header 'Select Portage config type (Enter=select, ESC=back)' \
            --preview-window 'right,60%,border-left' \
            --border-label-pos=3 \
            --border 'double' \
            --border-label="┨${PROG} - Portage Configuration┠" \
            --ansi \
            --color="${pwrfzf_colortheme}" \
            --preview="${BASH_SOURCE[0]} _config_preview {}")
        
        if [[ -z "$config_type" ]]; then
            break
        fi
        
        _manage_config_type "$config_type"
    done
}

function _config_preview() {
    local config_type="$1"
    
    case "$config_type" in
        "make.conf")
            _make_conf_preview
            ;;
        "sets")
            _sets_preview
            ;;
        *)
            _portage_config_preview "$config_type"
            ;;
    esac
}

function _make_conf_preview() {
    local make_conf="/etc/portage/make.conf"
    local make_conf_dir="/etc/portage/make.conf.d"
    
    echo "make.conf Configuration"
    echo "══════════════════════════════════════"
    
    if [[ -f "$make_conf" ]]; then
        echo "=== make.conf ==="
        echo "══════════════════════════════════════"
        cat "$make_conf" 2>/dev/null
        echo ""
    else
        echo "No make.conf found at: $make_conf"
        echo ""
    fi
    
    if [[ -d "$make_conf_dir" ]]; then
        echo "=== make.conf.d Directory ==="
        echo "Files found:"
        find "$make_conf_dir" -type f 2>/dev/null | head -10 | while read -r file; do
            echo "• $file"
        done
        echo ""
        
        local first_file=$(find "$make_conf_dir" -type f 2>/dev/null | head -1)
        if [[ -n "$first_file" ]]; then
            echo "First file content:"
            echo "File: $first_file"
            echo "══════════════════════════════════════"
            cat "$first_file" 2>/dev/null
        fi
    else
        echo "No make.conf.d directory found at: $make_conf_dir"
    fi
}

function _portage_config_preview() {
    local config_type="$1"
    local config_base="/etc/portage/package.$config_type"
    
    if [[ ! -e "$config_base" ]]; then
        echo "No configuration found"
        echo "Create new file or directory at:"
        echo "$config_base"
        return
    fi
    
    if [[ -f "$config_base" ]]; then
        echo "Single file configuration:"
        echo "File: $config_base"
        echo "══════════════════════════════════════"
        cat "$config_base" 2>/dev/null
    elif [[ -d "$config_base" ]]; then
        echo "Directory configuration:"
        echo "Path: $config_base"
        echo "Files found:"
        find "$config_base" -type f 2>/dev/null | head -10 | while read -r file; do
            echo "• $file"
        done
        echo ""
        local first_file=$(find "$config_base" -type f 2>/dev/null | head -1)
        if [[ -n "$first_file" ]]; then
            echo "First file content:"
            echo "File: $first_file"
            echo "══════════════════════════════════════"
            cat "$first_file" 2>/dev/null
        fi
    fi
    
    # Special handling for package.env - also check /etc/portage/env directory
    if [[ "$config_type" == "env" ]]; then
        local env_dir="/etc/portage/env"
        if [[ -d "$env_dir" ]]; then
            echo ""
            echo "══════════════════════════════════════"
            echo "Additional environment files in: $env_dir"
            echo "Files found:"
            find "$env_dir" -type f 2>/dev/null | head -10 | while read -r file; do
                echo "• $file"
            done
            echo ""
            local first_env_file=$(find "$env_dir" -type f 2>/dev/null | head -1)
            if [[ -n "$first_env_file" ]]; then
                echo "First env file content:"
                echo "File: $first_env_file"
                echo "══════════════════════════════════════"
                cat "$first_env_file" 2>/dev/null
            fi
        fi
    fi
}

function _sets_preview() {
    local sets_dir="/etc/portage/sets"
    local sets_conf="/etc/portage/sets.conf"
    
    echo "Package Sets Configuration"
    echo "══════════════════════════════════════"
    
    if [[ -f "$sets_conf" ]]; then
        echo "sets.conf:"
        echo "══════════════════════════════════════"
        cat "$sets_conf" 2>/dev/null
        echo ""
    fi
    
    if [[ -d "$sets_dir" ]]; then
        echo "Package set files:"
        find "$sets_dir" -type f 2>/dev/null | head -10 | while read -r file; do
            echo "• $file"
        done
        echo ""
        local first_file=$(find "$sets_dir" -type f 2>/dev/null | head -1)
        if [[ -n "$first_file" ]]; then
            echo "First set file content:"
            echo "File: $first_file"
            echo "══════════════════════════════════════"
            cat "$first_file" 2>/dev/null
        fi
    else
        echo "No package sets directory found at: $sets_dir"
    fi
}

function _manage_config_type() {
    local config_type="$1"
    
    case "$config_type" in
        "make.conf")
            _manage_make_conf
            ;;
        "sets")
            _manage_sets
            ;;
        *)
            _manage_portage_config "$config_type"
            ;;
    esac
}

function _manage_make_conf() {
    local make_conf="/etc/portage/make.conf"
    local make_conf_dir="/etc/portage/make.conf.d"
    
    while true; do
        local action
        action=$(echo -e "Edit make.conf\nBrowse make.conf.d files\nAdd make.conf.d file\nBack" | fzf \
            --bind 'esc:abort' \
            --header "Manage make.conf Configuration" \
            --preview-window 'right,60%,border-left' \
            --border-label-pos=3 \
            --border 'double' \
            --border-label="┨${PROG} - make.conf┠" \
            --ansi \
            --color="${pwrfzf_colortheme}" \
            --preview="${BASH_SOURCE[0]} _make_conf_action_preview {}")
        
        case "$action" in
            "Edit make.conf")
                _launch_editor "$make_conf"
                ;;
            "Browse make.conf.d files")
                _browse_make_conf_d
                ;;
            "Add make.conf.d file")
                _add_make_conf_d_file
                ;;
            "Back"|"")
                break
                ;;
        esac
    done
}

function _make_conf_action_preview() {
    local action="$1"
    
    case "$action" in
        "Edit make.conf")
            echo "Edit main make.conf file"
            echo "Global Portage settings like USE flags, CFLAGS, etc."
            echo ""
            echo "File: /etc/portage/make.conf"
            echo ""
            echo "Current content preview:"
            cat "/etc/portage/make.conf" 2>/dev/null | head -10 || echo "No make.conf found"
            ;;
        "Browse make.conf.d files")
            echo "Browse make.conf.d directory"
            echo "Split configuration across multiple files"
            echo ""
            echo "Available files:"
            find "/etc/portage/make.conf.d" -type f 2>/dev/null 2>/dev/null | head -5 | while read -r file; do
                echo "• $(basename "$file")"
            done || echo "No make.conf.d directory"
            ;;
        "Add make.conf.d file")
            echo "Add new make.conf.d file"
            echo "Create a new configuration file in make.conf.d"
            echo ""
            echo "Example file content:"
            echo "USE=\"X wayland pulseaudio\""
            echo "CFLAGS=\"-O2 -pipe\""
            echo "CXXFLAGS=\"\${CFLAGS}\""
            ;;
    esac
}

function _browse_make_conf_d() {
    local make_conf_dir="/etc/portage/make.conf.d"
    
    if [[ ! -d "$make_conf_dir" ]]; then
        echo "No make.conf.d directory found at: $make_conf_dir"
        echo "Create it? (y/N)"
        read -r answer
        if [[ "$answer" =~ ^[Yy]$ ]]; then
            ${PRIV_ESC} mkdir -p "$make_conf_dir"
            echo "Created: $make_conf_dir"
        else
            return
        fi
    fi
    
    while true; do
        local selected_file
        selected_file=$(find "$make_conf_dir" -type f 2>/dev/null | fzf \
            --bind 'enter:accept' \
            --bind 'esc:abort' \
            --header "Select make.conf.d file (Enter=edit, ESC=back)" \
            --preview-window 'right,60%,border-left' \
            --border-label-pos=3 \
            --border 'double' \
            --border-label="┨${PROG} - make.conf.d┠" \
            --ansi \
            --color="${pwrfzf_colortheme}" \
            --preview="echo '=== {} ==='; \
                      echo 'Size: $(du -h {} 2>/dev/null | cut -f1)'; \
                      echo 'Lines: $(wc -l < {} 2>/dev/null || echo 0)'; \
                      echo 'Modified: $(stat -c %y {} 2>/dev/null | cut -d. -f1)'; \
                      echo '══════════════════════════════════════'; \
                      cat {} 2>/dev/null")
        
        if [[ -z "$selected_file" ]]; then
            break
        fi
        
        _launch_editor "$selected_file"
    done
}

function _add_make_conf_d_file() {
    local make_conf_dir="/etc/portage/make.conf.d"
    local filename new_file
    
    echo "══════════════════════════════════════"
    echo "Add make.conf.d file"
    echo "Enter filename:"
    echo -n "Filename: "
    read -r filename
    [[ -z "$filename" ]] && return
    
    # Ensure it has .conf extension
    if [[ "$filename" != *.conf ]]; then
        filename="$filename.conf"
    fi
    
    new_file="$make_conf_dir/$filename"
    
    echo ""
    echo "══════════════════════════════════════"
    echo "CONFIRM CREATION:"
    echo "File: $new_file"
    echo ""
    echo "Create this file? (y/N)"
    read -r answer
    if [[ "$answer" =~ ^[Yy]$ ]]; then
        ${PRIV_ESC} mkdir -p "$make_conf_dir"
        ${PRIV_ESC} touch "$new_file"
        _pwrfzf_success "Created make.conf.d file: $filename"
        
        echo ""
        echo "Edit file now? (y/N)"
        read -r edit_answer
        if [[ "$edit_answer" =~ ^[Yy]$ ]]; then
            _launch_editor "$new_file"
        fi
    fi
}

function _manage_portage_config() {
    local config_type="$1"
    local config_base="/etc/portage/package.$config_type"
    
    while true; do
        local action
        action=$(echo -e "Preview files\nEdit files\nDelete files\nAdd new entry\nBack" | fzf \
            --bind 'esc:abort' \
            --header "Manage package.$config_type" \
            --preview-window 'right,60%,border-left' \
            --border-label-pos=3 \
            --border 'double' \
            --border-label="┨${PROG} - ${PORTAGE_CONFIG_TYPES[$config_type]}┠" \
            --ansi \
            --color="${pwrfzf_colortheme}" \
            --preview="${BASH_SOURCE[0]} _action_preview {} $config_type")
        
        case "$action" in
            "Preview files")
                _view_config_type "$config_type" | less
                ;;
            "Edit files")
                _edit_config_files "$config_type"
                ;;
            "Delete files")
                _delete_config_files_interactive "$config_type"
                ;;
            "Add new entry")
                _add_config_entry "$config_type"
                ;;
            "Back"|"")
                break
                ;;
        esac
    done
}

function _delete_config_files_interactive() {
    local config_type="$1"
    local config_base="/etc/portage/package.$config_type"
    
    if [[ ! -e "$config_base" ]]; then
        echo "No configuration found for package.$config_type"
        return
    fi
    
    # For package.env, also include the env directory
    local all_files=()
    if [[ "$config_type" == "env" && -d "/etc/portage/env" ]]; then
        while IFS= read -r -d '' file; do
            all_files+=("$file")
        done < <(find "/etc/portage/env" -type f -print0 2>/dev/null)
    fi
    
    if [[ -d "$config_base" ]]; then
        while IFS= read -r -d '' file; do
            all_files+=("$file")
        done < <(find "$config_base" -type f -print0 2>/dev/null)
    elif [[ -f "$config_base" ]]; then
        all_files+=("$config_base")
    fi
    
    if [[ ${#all_files[@]} -eq 0 ]]; then
        echo "No files found for package.$config_type"
        return
    fi
    
    echo "══════════════════════════════════════"
    echo "🗑️  DELETE CONFIGURATION FILES"
    echo "Config type: package.$config_type"
    echo ""
    
    while true; do
               local selected_file
        selected_file=$(printf '%s\n' "${all_files[@]}" | fzf \
            --bind 'enter:accept' \
            --bind 'esc:abort' \
            --header "Select file to delete (Enter=delete, ESC=back)" \
            --preview-window 'right,60%,border-left' \
            --border-label-pos=3 \
            --border 'double' \
            --border-label="┨${PROG} - Delete Files┠" \
            --ansi \
            --color="${pwrfzf_colortheme}" \
            --preview="bash -c 'echo \"=== {}\" ===; echo \"Size: \$(du -h {} 2>/dev/null | cut -f1)\"; echo \"Lines: \$(wc -l < {} 2>/dev/null || echo 0)\"; echo \"Modified: \$(stat -c %y {} 2>/dev/null | cut -d. -f1)\"; echo \"══════════════════════════════════════\"; cat {} 2>/dev/null'")

        if [[ -z "$selected_file" ]]; then
            break
        fi
        
        _delete_config_file "$selected_file" "$config_type"
        
        # Refresh file list after deletion
        all_files=()
        if [[ "$config_type" == "env" && -d "/etc/portage/env" ]]; then
            while IFS= read -r -d '' file; do
                all_files+=("$file")
            done < <(find "/etc/portage/env" -type f -print0 2>/dev/null)
        fi
        if [[ -d "$config_base" ]]; then
            while IFS= read -r -d '' file; do
                all_files+=("$file")
            done < <(find "$config_base" -type f -print0 2>/dev/null)
        elif [[ -f "$config_base" ]]; then
            all_files+=("$config_base")
        fi
        
        if [[ ${#all_files[@]} -eq 0 ]]; then
            echo "No more files to delete."
            break
        fi
    done
}

function _manage_sets() {
    while true; do
        local action
        action=$(echo -e "View sets.conf\nEdit sets.conf\nBrowse package sets\nAdd package set\nBack" | fzf \
            --bind 'esc:abort' \
            --header "Manage Package Sets" \
            --preview-window 'right,60%,border-left' \
            --border-label-pos=3 \
            --border 'double' \
            --border-label="┨${PROG} - Package Sets┠" \
            --ansi \
            --color="${pwrfzf_colortheme}" \
            --preview="${BASH_SOURCE[0]} _sets_action_preview {}")
        
        case "$action" in
            "View sets.conf")
                _view_sets_conf | less
                ;;
            "Edit sets.conf")
                _edit_sets_conf
                ;;
            "Browse package sets")
                _browse_package_sets
                ;;
            "Add package set")
                _add_package_set
                ;;
            "Back"|"")
                break
                ;;
        esac
    done
}

function _action_preview() {
    local action="$1"
    local config_type="$2"
    
    case "$action" in
        "Preview files")
            echo "Preview all configuration files"
            echo "Shows complete content of all files"
            echo ""
            echo "Preview of first file:"
            local config_base="/etc/portage/package.$config_type"
            local first_file=$(find "$config_base" -type f 2>/dev/null | head -1)
            if [[ -n "$first_file" ]]; then
                echo "File: $first_file"
                cat "$first_file" 2>/dev/null | head -5
            fi
            ;;
        "Edit files")
            echo "Edit configuration files"
            echo "Select and edit individual files"
            echo ""
            echo "Available files:"
            find "/etc/portage/package.$config_type" -type f 2>/dev/null | head -5
            ;;
        "Delete files")
            echo "Delete configuration files"
            echo "Permanently remove configuration files"
            echo ""
            echo "Available files for deletion:"
            find "/etc/portage/package.$config_type" -type f 2>/dev/null | head -5
            echo ""
            echo "⚠️  WARNING: This action cannot be undone!"
            ;;
        "Add new entry")
            echo "Add new configuration entry"
            echo "Add package with keywords, USE flags, etc."
            echo ""
            echo "Example:"
            case "$config_type" in
                accept_keywords) echo "dev-util/github-cli ~amd64" ;;
                use) echo "www-client/firefox -gtk +wayland pulseaudio" ;;
                mask) echo ">app-office/libreoffice-7.6.0" ;;
                unmask) echo "app-emulation/wine-proton" ;;
                env) echo "app-editors/neovim noinfo debug" ;;
            esac
            ;;
    esac
}

function _view_sets_conf() {
    local sets_conf="/etc/portage/sets.conf"
    
    if [[ -f "$sets_conf" ]]; then
        echo "=== sets.conf ==="
        echo "══════════════════════════════════════"
        cat "$sets_conf"
    else
        echo "No sets.conf found at: $sets_conf"
    fi
}

function _action_preview() {
    local action="$1"
    local config_type="$2"
    
    case "$action" in
        "Preview files")
            echo "Preview all configuration files"
            echo "Shows complete content of all files"
            echo ""
            echo "Preview of first file:"
            local config_base="/etc/portage/package.$config_type"
            local first_file=$(find "$config_base" -type f 2>/dev/null | head -1)
            if [[ -n "$first_file" ]]; then
                echo "File: $first_file"
                cat "$first_file" 2>/dev/null | head -5
            fi
            ;;
        "Edit files")
            echo "Edit configuration files"
            echo "Select and edit individual files"
            echo ""
            echo "Available files:"
            find "/etc/portage/package.$config_type" -type f 2>/dev/null | head -5
            ;;
        "Add new entry")
            echo "Add new configuration entry"
            echo "Add package with keywords, USE flags, etc."
            echo ""
            echo "Example:"
            case "$config_type" in
                accept_keywords) echo "dev-util/github-cli ~amd64" ;;
                use) echo "www-client/firefox -gtk +wayland pulseaudio" ;;
                mask) echo ">app-office/libreoffice-7.6.0" ;;
                unmask) echo "app-emulation/wine-proton" ;;
                env) echo "app-editors/neovim noinfo debug" ;;
            esac
            ;;
    esac
}

function _view_config_type() {
    local config_type="$1"
    local config_base="/etc/portage/package.$config_type"
    
    if [[ ! -e "$config_base" ]]; then
        echo "No configuration found for package.$config_type"
        return
    fi
    
    if [[ -f "$config_base" ]]; then
        echo "=== Single file: $config_base ==="
        echo "══════════════════════════════════════"
        cat "$config_base" 2>/dev/null
    elif [[ -d "$config_base" ]]; then
        find "$config_base" -type f 2>/dev/null | while read -r file; do
            echo ""
            echo "=== FILE: $file ==="
            echo "══════════════════════════════════════"
            cat "$file" 2>/dev/null
            echo ""
        done
    fi
    
    # Special handling for package.env - also show /etc/portage/env directory
    if [[ "$config_type" == "env" && -d "/etc/portage/env" ]]; then
        echo ""
        echo "=== ENVIRONMENT FILES (/etc/portage/env/) ==="
        echo "══════════════════════════════════════"
        find "/etc/portage/env" -type f 2>/dev/null | while read -r file; do
            echo ""
            echo "=== FILE: $file ==="
            echo "══════════════════════════════════════"
            cat "$file" 2>/dev/null
            echo ""
        done
    fi
}

function _edit_config_files() {
    local config_type="$1"
    local config_base="/etc/portage/package.$config_type"
    
    if [[ ! -e "$config_base" ]]; then
        echo "No configuration found. Create new file? (y/N)"
        read -r answer
        if [[ "$answer" =~ ^[Yy]$ ]]; then
            _launch_editor "$config_base"
        fi
        return
    fi
    
    # For package.env, also include the env directory
    local all_files=()
    if [[ "$config_type" == "env" && -d "/etc/portage/env" ]]; then
        while IFS= read -r -d '' file; do
            all_files+=("$file")
        done < <(find "/etc/portage/env" -type f -print0 2>/dev/null)
    fi
    
    if [[ -d "$config_base" ]]; then
        while IFS= read -r -d '' file; do
            all_files+=("$file")
        done < <(find "$config_base" -type f -print0 2>/dev/null)
    elif [[ -f "$config_base" ]]; then
        all_files+=("$config_base")
    fi
    
    if [[ ${#all_files[@]} -eq 0 ]]; then
        echo "No files found for package.$config_type"
        return
    fi
    
    # File browser
    while true; do
        local selected_file
        selected_file=$(printf '%s\n' "${all_files[@]}" | fzf \
            --bind 'enter:accept+abort' \
            --bind 'esc:abort' \
            --header "Select file to edit (Enter=edit, ESC=back)" \
            --preview-window 'right,60%,border-left' \
            --border-label-pos=3 \
            --border 'double' \
            --border-label="┨${PROG} - File Browser┠" \
            --ansi \
            --color="${pwrfzf_colortheme}" \
            --preview="echo '=== {} ==='; echo '══════════════════════════════════════'; cat {} 2>/dev/null")
        
        if [[ -z "$selected_file" ]]; then
            break
        fi
        
        _launch_editor "$selected_file"
    done
}

function _delete_config_file() {
    local file_path="$1"
    local config_type="$2"
    
    echo "══════════════════════════════════════"
    echo "🗑️  DELETE CONFIGURATION FILE"
    echo "File: $file_path"
    echo "Type: package.$config_type"
    echo ""
    echo "WARNING: This will permanently delete the file!"
    echo ""
    echo "Are you absolutely sure? (type 'yes' to confirm, any other like 'n' will cancel)"
    read -r confirmation
    
    if [[ "$confirmation" == "yes" ]]; then
        if ${PRIV_ESC} rm -f "$file_path"; then
            echo "✅ File deleted: $file_path"
            
            # Also remove empty parent directories
            local parent_dir=$(dirname "$file_path")
            if [[ -d "$parent_dir" ]] && [[ "$parent_dir" != "/etc/portage" ]]; then
                if ${PRIV_ESC} rmdir "$parent_dir" 2>/dev/null; then
                    echo "✅ Removed empty directory: $parent_dir"
                fi
            fi
        else
            echo "❌ Failed to delete file: $file_path"
        fi
    else
        echo "⚠️ Deletion cancelled"
    fi
}

function _launch_editor() {
    local file_path="$1"
    local editor
    
    # Detect available editors in order of preference
    if command -v nvim >/dev/null 2>&1; then
        editor="nvim"
    elif command -v nano >/dev/null 2>&1; then
        editor="nano"
    elif command -v vim >/dev/null 2>&1; then
        editor="vim"
    elif command -v vi >/dev/null 2>&1; then
        editor="vi"
    elif command -v gedit >/dev/null 2>&1; then
        editor="gedit"
    elif command -v kate >/dev/null 2>&1; then
        editor="kate"
    elif command -v leafpad >/dev/null 2>&1; then
        editor="leafpad"
    else
        _pwrfzf_error "No editor found! Please install nvim, nano, vim, or another editor."
        return 1
    fi
    
    # Ensure the file exists
    if [[ ! -f "$file_path" ]]; then
        ${PRIV_ESC} mkdir -p "$(dirname "$file_path")"
        ${PRIV_ESC} touch "$file_path"
    fi
    
    echo "Opening editor for: $file_path"
    echo "Using: $editor"
    echo "Press ESC then :wq to save and quit, or :q! to quit without saving"
    echo "Press any key to continue..."
    read -n1 -s
    
    # Use script to create a clean terminal environment
    if command -v script >/dev/null 2>&1; then
        if [[ $EUID -eq 0 ]]; then
            script -q -c "$editor '$file_path'" /dev/null
        else
            script -q -c "${PRIV_ESC} $editor '$file_path'" /dev/null
        fi
    else
        # Fallback without script command
        if [[ $EUID -eq 0 ]]; then
            $editor "$file_path"
        else
            ${PRIV_ESC} $editor "$file_path"
        fi
    fi
    
    # Clear any remaining terminal issues
    tput reset 2>/dev/null || true
    stty sane
}

function _add_config_entry() {
    local config_type="$1"
    local package config_entry new_entry config_file
    
    # Get package name with clear instructions
    echo "══════════════════════════════════════"
    echo "Enter package name (atom):"
    echo "Example: app-editors/neovim"
    echo -n "Package: "
    read -r package
    [[ -z "$package" ]] && return
    
    # Get config value based on type
    case "$config_type" in
        accept_keywords)
            echo ""
            echo "══════════════════════════════════════"
            echo "Select keywords for $package:"
            config_entry=$(echo -e "~amd64\n~arm64\namd64\narm64\n-**" | fzf --prompt "Keywords: ")
            ;;
        use)
            echo ""
            echo "══════════════════════════════════════"
            echo "Enter USE flags for $package:"
            echo "Format: +flag to enable, -flag to disable"
            echo "Example: +gtk -qt wayland pulseaudio"
            echo -n "USE flags: "
            read -r config_entry
            # Validate USE flags format (basic check)
            if [[ ! "$config_entry" =~ ^[+-]?[a-zA-Z0-9_]+([[:space:]]+[+-]?[a-zA-Z0-9_]+)*$ ]]; then
                _pwrfzf_warning "USE flags should start with + or - followed by flag name"
                echo "Examples: +gtk -qt, +wayland +pulseaudio, -doc -test"
            fi
            ;;
        mask|unmask)
            echo ""
            echo "══════════════════════════════════════"
            echo "Select mask type for $package:"
            config_entry=$(echo -e "$package\n>$package\n<$package\n=$package" | fzf --prompt "Mask: ")
            ;;
        env)
            echo ""
            echo "══════════════════════════════════════"
            echo "Select environment for $package:"
            config_entry=$(echo -e "noinfo\ndebug\nconfcache\nstrict\ntest" | fzf --prompt "Environment: ")
            ;;
        *)
            echo ""
            echo "══════════════════════════════════════"
            echo "Enter configuration for $package:"
            read -r config_entry
            ;;
    esac
    [[ -z "$config_entry" ]] && return
    
    new_entry="$package $config_entry"
    
    # Select target file
    echo ""
    echo "══════════════════════════════════════"
    echo "Select target configuration file:"
    config_file=$(_select_config_file "$config_type")
    [[ -z "$config_file" ]] && return
    
    echo ""
    echo "══════════════════════════════════════"
    echo "CONFIRM ADDITION:"
    echo "Entry: $new_entry"
    echo "File: $config_file"
    echo ""
    echo "Add this entry? (y/N)"
    read -r answer
    if [[ "$answer" =~ ^[Yy]$ ]]; then
        # Create directory if needed
        ${PRIV_ESC} mkdir -p "$(dirname "$config_file")"
        echo "$new_entry" | ${PRIV_ESC} tee -a "$config_file" >/dev/null
        _pwrfzf_success "Added to $config_file: $new_entry"
    else
        _pwrfzf_warning "Addition cancelled"
    fi
}

function _select_config_file() {
    local config_type="$1"
    local config_base="/etc/portage/package.$config_type"
    
    # Build list of files
    local all_files=()
    
    # For package.env, include the env directory
    if [[ "$config_type" == "env" && -d "/etc/portage/env" ]]; then
        while IFS= read -r -d '' file; do
            all_files+=("$file")
        done < <(find "/etc/portage/env" -type f -print0 2>/dev/null)
    fi
    
    # Add files from the main config directory
    if [[ -d "$config_base" ]]; then
        while IFS= read -r -d '' file; do
            all_files+=("$file")
        done < <(find "$config_base" -type f -print0 2>/dev/null)
    elif [[ -f "$config_base" ]]; then
        all_files+=("$config_base")
    fi
    
    # If no files exist, go straight to file creation
    if [[ ${#all_files[@]} -eq 0 ]]; then
        echo "No existing files found. Creating new file..." >&2
        _create_new_config_file_simple "$config_type"
        return
    fi
    
    # Prepare options for fzf
    local options=()
    for file in "${all_files[@]}"; do
        local line_count=$(wc -l < "$file" 2>/dev/null || echo 0)
        options+=("$file|$file ($line_count lines)")
    done
    options+=("[CREATE_NEW]|Create new file")
    
    # Show selection
    local selected
    selected=$(printf "%s\n" "${options[@]}" | fzf \
        --delimiter '|' \
        --with-nth=2 \
        --prompt "Select file: " \
        --preview "if [[ {1} == '[CREATE_NEW]' ]]; then echo 'Create new file'; else echo '=== {1} ==='; echo '══════════════════════════════════════'; cat {1} 2>/dev/null | head -20; fi" 2>/dev/null | \
        cut -d'|' -f1)
    
    if [[ "$selected" == "[CREATE_NEW]" ]]; then
        _create_new_config_file_simple "$config_type"
    else
        echo "$selected"
    fi
}

function _create_new_config_file_simple() {
    local config_type="$1"
    local config_base="/etc/portage/package.$config_type"
    local default_filename=""
    
    # Suggest meaningful default filename
    case "$config_type" in
        accept_keywords) default_filename="custom-keywords" ;;
        use) default_filename="custom-use" ;;
        mask) default_filename="custom-mask" ;;
        unmask) default_filename="custom-unmask" ;;
        env) default_filename="custom-env" ;;
        *) default_filename="custom-config" ;;
    esac
    
    # Use a temporary file to capture the filename
    local temp_file=$(mktemp)
    
    {
        echo "══════════════════════════════════════" >&2
        echo "Create new file for package.$config_type" >&2
        echo "Enter filename [${default_filename}]:" >&2
        echo "(Press Enter for default, or type new name)" >&2
        echo -n "Filename: " >&2
    }
    
    read -r filename
    filename="${filename:-$default_filename}"
    filename=$(basename "$filename")
    
    # Determine full path
    local full_path="$config_base/$filename"
    
    {
        echo "" >&2
        echo "Creating: $full_path" >&2
    }
    
    if ${PRIV_ESC} mkdir -p "$(dirname "$full_path")" && ${PRIV_ESC} touch "$full_path"; then
        echo "SUCCESS: Created $full_path" >&2
        # Return ONLY the clean path
        echo "$full_path"
        return 0
    else
        echo "ERROR: Failed to create $full_path" >&2
        return 1
    fi
}

function _add_keyword_entry() {
    local package="$1"
    
    echo ""
    echo "══════════════════════════════════════"
    echo "Unmasking package: $package"
    
    # Select keyword
    local selected_keyword
    selected_keyword=$(echo -e "~amd64\n~arm64\namd64\narm64\n-**" | fzf --prompt "Select keyword: ")
    [[ -z "$selected_keyword" ]] && return 1
    
    local new_entry="$package $selected_keyword"
    
    # Select file - capture output and clean it
    echo ""
    echo "══════════════════════════════════════"
    echo "Select file to add keyword to:"
    local config_file
    config_file=$(_select_config_file "accept_keywords")
    
    # Clean the config_file variable - remove any non-path content
    config_file=$(echo "$config_file" | grep -E '^/etc/portage/' | head -1)
    
    if [[ -z "$config_file" ]] || [[ ! -f "$config_file" ]]; then
        _pwrfzf_error "Invalid or no file selected: $config_file"
        return 1
    fi
    
    # Confirm addition
    echo ""
    echo "══════════════════════════════════════"
    echo "CONFIRM ADDITION:"
    echo "Entry: $new_entry"
    echo "File: $config_file"
    echo ""
    echo "Add this entry? (y/N)"
    read -r confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        # Ensure directory exists (should already from creation)
        ${PRIV_ESC} mkdir -p "$(dirname "$config_file")"
        
        # Add the entry to the file
        if echo "$new_entry" | ${PRIV_ESC} tee -a "$config_file" >/dev/null; then
            _pwrfzf_success "Added to $config_file: $new_entry"
            
            # Verify the entry was written
            if ${PRIV_ESC} grep -q "$package" "$config_file" 2>/dev/null; then
                _pwrfzf_verbose "Entry successfully verified in file"
            else
                _pwrfzf_warning "Entry may not have been written correctly"
            fi
            return 0
        else
            _pwrfzf_error "Failed to write to $config_file"
            return 1
        fi
    else
        _pwrfzf_warning "Cancelled"
        return 1
    fi
}

function _edit_sets_conf() {
    local sets_conf="/etc/portage/sets.conf"
    _launch_editor "$sets_conf"
}

function _browse_package_sets() {
    local sets_dir="/etc/portage/sets"
    
    if [[ ! -d "$sets_dir" ]]; then
        echo "No package sets directory found at: $sets_dir"
        return
    fi
    
    while true; do
        local selected_file
        selected_file=$(find "$sets_dir" -type f 2>/dev/null | fzf \
            --bind 'enter:accept+abort' \
            --bind 'esc:abort' \
            --header "Select package set to edit (Enter=edit, ESC=back)" \
            --preview-window 'right,60%,border-left' \
            --border-label-pos=3 \
            --border 'double' \
            --border-label="┨${PROG} - Package Sets┠" \
            --ansi \
            --color="${pwrfzf_colortheme}" \
            --preview="echo '=== {} ==='; echo '══════════════════════════════════════'; cat {} 2>/dev/null")
        
        if [[ -z "$selected_file" ]]; then
            break
        fi
        
        _launch_editor "$selected_file"
    done
}

function _add_package_set() {
    local sets_dir="/etc/portage/sets"
    local set_name new_set_file
    
    echo "══════════════════════════════════════"
    echo "Enter package set name:"
    echo -n "Set name: "
    read -r set_name
    [[ -z "$set_name" ]] && return
    
    new_set_file="$sets_dir/$set_name"
    
    echo ""
    echo "══════════════════════════════════════"
    echo "CONFIRM CREATION:"
    echo "Package set: $set_name"
    echo "File: $new_set_file"
    echo ""
    echo "Create this package set? (y/N)"
    read -r answer
    if [[ "$answer" =~ ^[Yy]$ ]]; then
        ${PRIV_ESC} mkdir -p "$sets_dir"
        ${PRIV_ESC} touch "$new_set_file"
        _pwrfzf_success "Created package set: $set_name"
        
        echo ""
        echo "Edit set now? (y/N)"
        read -r edit_answer
        if [[ "$edit_answer" =~ ^[Yy]$ ]]; then
            _launch_editor "$new_set_file"
        fi
    fi
}

# Sync repositories
function _sync_repositories() {
    _pwrfzf_verbose "Syncing repositories..."
    if ${PRIV_ESC} emaint sync --all; then
        _pwrfzf_success "Repositories synced successfully"
    else
        _pwrfzf_error "Failed to sync repositories"
    fi
}

# Run preserved rebuild
function _preserved_rebuild() {
    _pwrfzf_verbose "Running preserved rebuild..."
    if ${EMERGE_CMD} -1 @preserved-rebuild; then
        _pwrfzf_success "Preserved rebuild completed successfully"
    else
        _pwrfzf_error "Preserved rebuild failed"
    fi
}

# Enhanced package installation - try direct install first, analyze on failure
function _install_packages_with_fallback() {
    local emerge_args=("$@")
    local max_retries=3
    local retry_count=0
    
    while [[ $retry_count -lt $max_retries ]]; do
        echo "══════════════════════════════════════"
        echo "Attempt $((retry_count + 1)) of $max_retries"
        echo "Installing: ${emerge_args[*]}"
        
        # Try direct installation first
        echo ">>> Running direct installation..."
        ${EMERGE_CMD} "${emerge_args[@]}"
        local emerge_exit_code=$?
        
        if [[ $emerge_exit_code -eq 0 ]]; then
            echo "✅ Package installation completed successfully"
            return 0
        elif [[ $emerge_exit_code -eq 130 ]]; then
            # Exit code 130 (SIGINT) means user cancelled with Ctrl+C
            echo "⏹️ Installation cancelled by user"
            return 130
        else
            ((retry_count++))
            echo "❌ Installation failed (attempt $retry_count). Analyzing issues..."
            
            # Now run --pretend to analyze what went wrong
            local pretend_output
            pretend_output=$(${EMERGE_CMD} --pretend "${emerge_args[@]}" 2>&1)
            local pretend_exit_code=$?
            
            echo ""
            echo "══════════════════════════════════════"
            echo "DEPENDENCY ANALYSIS:"
            echo "$pretend_output"
            
            if [[ $pretend_exit_code -ne 0 ]]; then
                # Analyze the failure - IMPROVED DETECTION
                local masked_packages=()
                local use_flag_packages=()
                local use_flag_suggestions=()
                local circular_deps_packages=()
                local circular_deps_suggestions=()
                local keyword_packages=()

                # IMPROVED: Check for masked packages (both keyword and hard masked)
                if echo "$pretend_output" | grep -q "masked"; then
                    # Extract package names from masked messages
                    masked_packages=($(echo "$pretend_output" | grep -E "!!!.*masked" | \
                        sed -E 's/.*"([^"]+)".*/\1/' | sort -u))
                fi
                
                # IMPROVED: Check specifically for keyword masking
                if echo "$pretend_output" | grep -q "keyword.*masked"; then
                    keyword_packages=($(echo "$pretend_output" | grep -E "!!!.*keyword.*masked" | \
                        sed -E 's/.*"([^"]+)".*/\1/' | sort -u))
                fi

                # Check for circular dependencies
                if echo "$pretend_output" | grep -q "circular dependencies"; then
                    local fix_line
                    fix_line=$(echo "$pretend_output" | grep -A2 "It might be possible to break this cycle" | grep "Change USE:" | head -1)
                    
                    if [[ "$fix_line" =~ -\ ([^[:space:]]+).*Change\ USE:\ ([+-][a-zA-Z0-9_-]+) ]]; then
                        local pkg="${BASH_REMATCH[1]}"
                        local flag="${BASH_REMATCH[2]}"
                        circular_deps_packages=("$pkg")
                        circular_deps_suggestions=("$pkg:$flag")
                    fi
                fi
                
                # Check for USE flag requirements
                local use_line=$(echo "$pretend_output" | grep "Change USE:" | head -1)
                if [[ -n "$use_line" ]]; then
                    if [[ "$use_line" =~ -\ ([^[:space:]]+).*Change\ USE:\ ([+-][^[:space:]]+) ]]; then
                        local pkg="${BASH_REMATCH[1]}"
                        local flag="${BASH_REMATCH[2]}"
                        use_flag_packages+=("$pkg")
                        use_flag_suggestions+=("$pkg:$flag")
                    fi
                fi

                # SHOW INTERACTIVE OPTIONS BASED ON ANALYSIS
                echo ""
                echo "══════════════════════════════════════"
                echo "🛠️  CONFIGURATION ISSUES DETECTED"
                
                local options=()
                local option_descriptions=()
                
                if [[ ${#masked_packages[@]} -gt 0 ]]; then
                    options+=("1")
                    option_descriptions+=("Unmask packages: ${masked_packages[*]}")
                fi
                
                if [[ ${#keyword_packages[@]} -gt 0 ]]; then
                    options+=("2") 
                    option_descriptions+=("Add keywords for: ${keyword_packages[*]}")
                fi
                
                if [[ ${#use_flag_packages[@]} -gt 0 ]]; then
                    options+=("3")
                    option_descriptions+=("Manage USE flags for: ${use_flag_packages[*]}")
                fi
                
                if [[ ${#circular_deps_packages[@]} -gt 0 ]]; then
                    options+=("4")
                    option_descriptions+=("Fix circular dependencies: ${circular_deps_packages[*]}")
                fi
                
                options+=("5" "6" "7")
                option_descriptions+=("Open Portage config manager (all files)" "Let emerge handle automatically (--autounmask-use)")
                option_descriptions+=("Skip problematic packages and retry")

                # Display options
                for i in "${!options[@]}"; do
                    echo "${options[i]}) ${option_descriptions[i]}"
                done
                echo "0) Abort installation"
                
                echo ""
                echo -n "Select action: "
                read -r choice
                
                case $choice in
                    1)
                        if [[ ${#masked_packages[@]} -gt 0 ]]; then
                            _unmask_packages "${masked_packages[@]}"
                            echo "🔄 Configuration updated. Retrying..."
                            # Continue to next iteration (retry)
                            continue
                        fi
                        ;;
                    2)
                        if [[ ${#keyword_packages[@]} -gt 0 ]]; then
                            for pkg in "${keyword_packages[@]}"; do
                                _add_keyword_entry "$pkg"
                            done
                            echo "🔄 Configuration updated. Retrying..."
                            continue
                        fi
                        ;;
                    3)
                        if [[ ${#use_flag_packages[@]} -gt 0 ]]; then
                            _manage_use_flags_interactive "${use_flag_packages[@]}"
                            echo "🔄 Configuration updated. Retrying..."
                            continue
                        fi
                        ;;
                    4)
                        if [[ ${#circular_deps_packages[@]} -gt 0 ]]; then
                            if [[ ${#circular_deps_suggestions[@]} -gt 0 ]]; then
                                _apply_suggested_use_flags "${circular_deps_suggestions[@]}"
                            else
                                _manage_use_flags_interactive "${circular_deps_packages[@]}"
                            fi
                            echo "🔄 Configuration updated. Retrying..."
                            continue
                        fi
                        ;;
                    5)
                        # Open Portage config manager for manual editing
                        _portage_config_manager
                        echo "🔄 Configuration updated. Retrying..."
                        continue
                        ;;
                    6)
                        echo "🔧 Allowing emerge to handle automatically..."
                        emerge_args=("--autounmask-use" "${emerge_args[@]}")
                        echo "🔄 Retrying with automatic unmasking..."
                        continue
                        ;;
                    7)
                        echo "⏭️ Skipping problematic packages..."
                        local all_problem_packages=("${masked_packages[@]}" "${keyword_packages[@]}" "${use_flag_packages[@]}" "${circular_deps_packages[@]}")
                        for pkg in "${all_problem_packages[@]}"; do
                            emerge_args=(${emerge_args[@]//$pkg/})
                        done
                        # Remove empty arguments
                        emerge_args=($(printf '%s\n' "${emerge_args[@]}" | grep -v '^$'))
                        echo "🔄 Retrying without problematic packages..."
                        continue
                        ;;
                    0|*)
                        echo "❌ Installation aborted by user"
                        return 1
                        ;;
                esac
            else
                # Pretend passed but actual install failed - unknown error
                echo "❌ Unknown installation error. Pretend passed but install failed."
                if [[ $retry_count -lt $max_retries ]]; then
                    echo "🔄 Retrying..."
                    continue
                fi
            fi
        fi
    done
    
    echo "❌ Maximum retry attempts reached"
    return 1
}

# Apply suggested USE flag changes automatically
function _apply_suggested_use_flags() {
    local suggestions=("$@")
    
    echo "🔧 Applying suggested USE flag changes..."
    
    for suggestion in "${suggestions[@]}"; do
        local pkg="${suggestion%:*}"
        local flag="${suggestion#*:}"
        
        # Remove the + or - prefix from the flag for package.use format
        # Also remove any trailing parenthesis or other characters
        local clean_flag="${flag#[+-]}"
        clean_flag="${clean_flag%)}"  # Remove trailing parenthesis if present
        clean_flag="${clean_flag%%[[:space:]]*}"  # Remove any trailing spaces
        
        echo "══════════════════════════════════════"
        echo "Applying USE flag change:"
        echo "Original package: $pkg"
        echo "USE flag: $clean_flag"
        
        # ALWAYS USE >= FORMAT for versioned packages
        local package_atom
        
        # SIMPLE VERSION DETECTION - check if package contains version numbers
        if [[ "$pkg" =~ -[0-9] ]]; then
            # Package has version - ALWAYS use >= format
            package_atom=">=$pkg"
            echo "Using: $package_atom (this version and newer)"
        else
            # Package without version - use as is
            package_atom="$pkg"
            echo "Using package: $package_atom"
        fi
        
        # Select target file
        echo "Select file to add USE flag:"
        local config_file
        config_file=$(_select_config_file "use")
        config_file=$(echo "$config_file" | grep -E '^/etc/portage/' | head -1)
        
        if [[ -z "$config_file" ]] || [[ ! "$config_file" =~ ^/etc/portage/ ]]; then
            echo "❌ Invalid file selected for $package_atom"
            continue
        fi
        
        # Create the USE flag entry with proper format
        local use_entry="$package_atom $clean_flag"
        
        # Confirm addition
        echo ""
        echo "══════════════════════════════════════"
        echo "CONFIRM ADDITION:"
        echo "Entry: $use_entry"
        echo "File: $config_file"
        echo "Note: USE flag '$clean_flag' will be enabled for $package_atom"
        echo ""
        echo "Add this entry? (y/N)"
        read -r confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            ${PRIV_ESC} mkdir -p "$(dirname "$config_file")"
            echo "$use_entry" | ${PRIV_ESC} tee -a "$config_file" >/dev/null
            
            # Validate the entry was written correctly
            if ${PRIV_ESC} grep -q "$package_atom" "$config_file" 2>/dev/null; then
                echo "✅ Added to $config_file: $use_entry"
                
                # Show what was actually written
                echo "Written to file: $use_entry"
            else
                echo "❌ Failed to verify entry in $config_file"
            fi
        else
            echo "⚠️ Skipped USE flag change for $pkg"
        fi
    done
    
    # Return success to allow retry
    return 0
}

# Interactive USE flag management for packages
function _manage_use_flags_interactive() {
    local packages=("$@")
    
    _pwrfzf_verbose "Managing USE flags for packages: ${packages[*]}"
    
    for package in "${packages[@]}"; do
        echo "══════════════════════════════════════"
        echo "Managing USE flags for: $package"
        
        while true; do
            local action
            action=$(echo -e "View current USE flags\nAdd USE flags\nRemove USE flags\nView available USE flags\nSkip this package\nDone with this package" | fzf \
                --bind 'esc:abort' \
                --header "Manage USE flags for: $package" \
                --preview-window 'right,60%,border-left' \
                --border-label-pos=3 \
                --border 'double' \
                --border-label="┨${PROG} - USE Flags┠" \
                --ansi \
                --color="${pwrfzf_colortheme}" \
                --preview="bash -c '\"${BASH_SOURCE[0]}\" _use_flags_preview \"$package\" {}'")
            
            case "$action" in
                "View current USE flags")
                    _view_current_use_flags "$package"
                    ;;
                "Add USE flags")
                    _add_use_flags_interactive "$package"
                    ;;
                "Remove USE flags")
                    _remove_use_flags_interactive "$package"
                    ;;
                "View available USE flags")
                    _view_available_use_flags "$package"
                    ;;
                "Skip this package")
                    _pwrfzf_verbose "Skipping USE flag management for: $package"
                    break
                    ;;
                "Done with this package"|"")
                    _pwrfzf_verbose "Finished USE flag management for: $package"
                    break
                    ;;
            esac
        done
    done
}

# USE flags preview function
function _use_flags_preview() {
    local package="$1"
    local action="$2"
    
    case "$action" in
        "View current USE flags")
            echo "=== CURRENT USE FLAGS FOR: $package ==="
            equery uses "$package" 2>/dev/null || echo "Unable to query USE flags"
            echo ""
            echo "=== CURRENT PACKAGE.USE CONFIGURATION ==="
            grep -r "$package" "/etc/portage/package.use" 2>/dev/null | head -10 || echo "No custom USE configuration"
            ;;
        "Add USE flags")
            echo "=== AVAILABLE USE FLAGS FOR: $package ==="
            local ebuild_path
            ebuild_path=$(equery which "$package" 2>/dev/null)
            if [[ -n "$ebuild_path" ]]; then
                grep -E "^IUSE=" "$ebuild_path" 2>/dev/null | head -1 | sed 's/IUSE=//' | tr -d '"' | xargs -n1 | sort | column
            else
                echo "Unable to find ebuild"
            fi
            echo ""
            echo "=== CURRENT CONFIGURATION ==="
            grep -r "$package" "/etc/portage/package.use" 2>/dev/null | head -5 || echo "No current configuration"
            ;;
        "Remove USE flags")
            echo "=== CURRENT USE CONFIGURATION ==="
            grep -r "$package" "/etc/portage/package.use" 2>/dev/null | head -10 || echo "No configuration to remove"
            ;;
        "View available USE flags")
            echo "=== ALL AVAILABLE USE FLAGS FOR: $package ==="
            local ebuild_path
            ebuild_path=$(equery which "$package" 2>/dev/null)
            if [[ -n "$ebuild_path" ]]; then
                echo "IUSE flags from ebuild:"
                grep -E "^IUSE=" "$ebuild_path" 2>/dev/null | head -1 | sed 's/IUSE=//' | tr -d '"' | xargs -n1 | sort
                echo ""
                echo "Global USE flags (from make.conf):"
                grep -E "^USE=" /etc/portage/make.conf 2>/dev/null | head -1 | sed 's/USE=//' | tr -d '"' | xargs -n1 | sort | head -20
            else
                echo "Unable to find ebuild for $package"
            fi
            ;;
    esac
}

# Add USE flags interactively
function _add_use_flags_interactive() {
    local package="$1"
    
    echo "══════════════════════════════════════"
    echo "Add USE flags for: $package"
    
    # Get available USE flags
    local available_flags=()
    local ebuild_path
    ebuild_path=$(equery which "$package" 2>/dev/null)
    
    if [[ -n "$ebuild_path" ]]; then
        available_flags=($(grep -E "^IUSE=" "$ebuild_path" 2>/dev/null | head -1 | sed 's/IUSE=//' | tr -d '"' | xargs -n1 | sort))
    fi
    
    if [[ ${#available_flags[@]} -eq 0 ]]; then
        _pwrfzf_error "No USE flags found for $package"
        return 1
    fi
    
    # Let user select USE flags
    local selected_flags=()
    while true; do
        local flag
        flag=$(printf "%s\n" "${available_flags[@]}" "DONE" | fzf \
            --prompt "Select USE flag to add (DONE when finished): " \
            --preview "echo 'Flag: {}'; echo ''; echo 'Description would go here'")
        
        if [[ "$flag" == "DONE" ]]; then
            break
        elif [[ -n "$flag" ]]; then
            selected_flags+=("$flag")
            _pwrfzf_verbose "Selected flag: $flag"
        fi
    done
    
    if [[ ${#selected_flags[@]} -eq 0 ]]; then
        _pwrfzf_warning "No USE flags selected"
        return 1
    fi
    
    # Ask for enable/disable - but store without +/-
    local use_entry="$package"
    for flag in "${selected_flags[@]}"; do
        local action
        action=$(echo -e "Enable $flag\nDisable $flag" | fzf --prompt "Action for $flag: ")
        if [[ "$action" == "Enable $flag" ]]; then
            use_entry+=" $flag"
        elif [[ "$action" == "Disable $flag" ]]; then
            use_entry+=" -$flag"
        fi
    done
    
    # Select target file
    echo ""
    echo "══════════════════════════════════════"
    echo "Select file to add USE flags:"
    local config_file
    config_file=$(_select_config_file "use")
    config_file=$(echo "$config_file" | grep -E '^/etc/portage/' | head -1)
    
    if [[ -z "$config_file" ]] || [[ ! "$config_file" =~ ^/etc/portage/ ]]; then
        _pwrfzf_error "Invalid file selected"
        return 1
    fi
    
    # Confirm addition
    echo ""
    echo "══════════════════════════════════════"
    echo "CONFIRM ADDITION:"
    echo "Entry: $use_entry"
    echo "File: $config_file"
    echo ""
    echo "Add this entry? (y/N)"
    read -r confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        ${PRIV_ESC} mkdir -p "$(dirname "$config_file")"
        echo "$use_entry" | ${PRIV_ESC} tee -a "$config_file" >/dev/null
        _pwrfzf_success "Added to $config_file: $use_entry"
        return 0
    else
        _pwrfzf_warning "Cancelled"
        return 1
    fi
}

# Helper function to select proper package atom format
function _select_package_atom_format() {
    local package="$1"
    local versions=()
    
    # Try to get available versions
    if command -v eix >/dev/null 2>&1; then
        versions=($(eix -e "$package" 2>/dev/null | grep -E "^.*\[[UI]\]" | awk '{print $1}' | head -5))
    fi
    
    local options=("$package" "=$package" ">=$package" "<=$package")
    
    # Add specific versions if available
    for version in "${versions[@]}"; do
        options+=("$version" "=$version")
    done
    
    options+=("Custom entry")
    
    local selected
    selected=$(printf "%s\n" "${options[@]}" | fzf \
        --prompt "Select package atom format: " \
        --preview "echo 'Selected: {}'; echo ''; echo 'This will be written to package.use'")
    
    if [[ "$selected" == "Custom entry" ]]; then
        echo ""
        echo "Enter custom package atom:"
        read -r custom_atom
        echo "$custom_atom"
    else
        echo "$selected"
    fi
}

# View current USE flags
function _view_current_use_flags() {
    local package="$1"
    echo "=== CURRENT USE FLAGS FOR: $package ==="
    equery uses "$package" 2>/dev/null || echo "Unable to query USE flags"
    echo ""
    echo "=== PACKAGE.USE CONFIGURATION ==="
    grep -r "$package" "/etc/portage/package.use" 2>/dev/null | head -20 || echo "No custom USE configuration"
    echo ""
    echo "Press any key to continue..."
    read -n1 -s
}

# View available USE flags
function _view_available_use_flags() {
    local package="$1"
    echo "=== AVAILABLE USE FLAGS FOR: $package ==="
    local ebuild_path
    ebuild_path=$(equery which "$package" 2>/dev/null)
    if [[ -n "$ebuild_path" ]]; then
        echo "IUSE flags from ebuild:"
        grep -E "^IUSE=" "$ebuild_path" 2>/dev/null | head -1 | sed 's/IUSE=//' | tr -d '"' | xargs -n1 | sort | column
    else
        echo "Unable to find ebuild"
    fi
    echo ""
    echo "Press any key to continue..."
    read -n1 -s
}

# Remove USE flags interactively
function _remove_use_flags_interactive() {
    local package="$1"
    
    echo "══════════════════════════════════════"
    echo "Remove USE flags for: $package"
    
    # Get current USE flag configuration
    local current_config
    current_config=$(grep -r "$package" "/etc/portage/package.use" 2>/dev/null)
    
    if [[ -z "$current_config" ]]; then
        _pwrfzf_warning "No USE flag configuration found for $package"
        return 1
    fi
    
    # Let user select which configuration to remove
    local config_to_remove
    config_to_remove=$(echo "$current_config" | fzf \
        --prompt "Select configuration to remove: " \
        --preview "echo 'Current entry: {}'")
    
    if [[ -z "$config_to_remove" ]]; then
        _pwrfzf_warning "No configuration selected"
        return 1
    fi
    
    # Extract the file path and line
    local config_file=$(echo "$config_to_remove" | cut -d: -f1)
    local config_line=$(echo "$config_to_remove" | cut -d: -f2-)
    
    echo ""
    echo "══════════════════════════════════════"
    echo "CONFIRM REMOVAL:"
    echo "Entry: $config_line"
    echo "File: $config_file"
    echo ""
    echo "Remove this entry? (y/N)"
    read -r confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        # Remove the specific line from the file
        ${PRIV_ESC} sed -i "\|$config_line|d" "$config_file"
        _pwrfzf_success "Removed from $config_file: $config_line"
        return 0
    else
        _pwrfzf_warning "Cancelled"
        return 1
    fi
}

# Function to unmask packages
function _unmask_packages() {
    local packages=("$@")
    local real_packages=()
    
    # Filter out only valid package atoms (category/name format)
    for package in "${packages[@]}"; do
        if [[ "$package" =~ ^[a-zA-Z0-9+_.-]+/[a-zA-Z0-9+_.-]+$ ]]; then
            real_packages+=("$package")
        fi
    done
    
    if [[ ${#real_packages[@]} -eq 0 ]]; then
        _pwrfzf_warning "No valid package names found in: ${packages[*]}"
        return 1
    fi
    
    _pwrfzf_verbose "Unmasking packages: ${real_packages[*]}"
    
    for package in "${real_packages[@]}"; do
        echo "══════════════════════════════════════"
        echo "Processing: $package"
        
        # Check what kind of masking is preventing installation
        local mask_info
        mask_info=$(emerge --pretend "$package" 2>&1 | grep -E "(masked by|keyword)" | head -1)
        
        if [[ "$mask_info" =~ keyword ]]; then
            _pwrfzf_verbose "Package $package is masked by keywords"
            _add_keyword_entry "$package"
        elif [[ "$mask_info" =~ masked ]]; then
            _pwrfzf_verbose "Package $package is hard masked"
            echo "This package is hard masked and cannot be easily unmasked."
            echo "You may need to check package.mask files or use package.unmask."
            echo ""
            echo "Add to package.unmask? (y/N)"
            read -r answer
            if [[ "$answer" =~ ^[Yy]$ ]]; then
                _add_unmask_entry "$package"
            fi
        else
            _pwrfzf_warning "Unknown masking type for $package"
        fi
    done
}

# Function to add unmask entry
function _add_unmask_entry() {
    local package="$1"
    
    echo "══════════════════════════════════════"
    echo "Unmasking package: $package"
    local new_entry="$package"
    local config_file
    
    # Select target file for package.unmask
    echo "Select file to add unmask entry:"
    config_file=$(_select_config_file "unmask")
    [[ -z "$config_file" ]] && return
    
    echo ""
    echo "══════════════════════════════════════"
    echo "CONFIRM ADDITION:"
    echo "Entry: $new_entry"
    echo "File: $config_file"
    echo ""
    echo "Add this entry? (y/N)"
    read -r answer
    if [[ "$answer" =~ ^[Yy]$ ]]; then
        # Create directory if needed
        ${PRIV_ESC} mkdir -p "$(dirname "$config_file")"
        echo "$new_entry" | ${PRIV_ESC} tee -a "$config_file" >/dev/null
        _pwrfzf_success "Added to $config_file: $new_entry"
    fi
}

# Main function
function main() {
    local ARGS=() emerge_args=() SearchInput
    
    # Use EMERGE_DEFAULT_OPTS if set (now properly loaded from make.conf)
    if [[ -n "$EMERGE_DEFAULT_OPTS" ]]; then
        _pwrfzf_verbose "Using EMERGE_DEFAULT_OPTS: $EMERGE_DEFAULT_OPTS"
        
        # Use eval to properly handle shell quoting in EMERGE_DEFAULT_OPTS
        # This correctly handles arguments with spaces and quotes
        eval "emerge_args+=($EMERGE_DEFAULT_OPTS)"
    fi

    # Always include --ask for safety in interactive mode
    emerge_args+=("--ask")

    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                _pwrfzf_help
                exit 0
                ;;
            --help-full)
                _pwrfzf_help_full
                exit 0
                ;;
            -k|--keybindings)
                _pwrfzf_keys
                exit 0
                ;;
            -V|--version)
                _pwrfzf_version
                exit 0
                ;;
            -c|--config)
                _portage_config_manager
                exit 0
                ;;
            --sync)
                _sync_repositories
                exit 0
                ;;
            --preserved-rebuild)
                _preserved_rebuild
                exit 0
                ;;
            __fzf_preview)
                __fzf_preview "$2"
                exit 0
                ;;
            -*)
                emerge_args+=("$1")
                ;;
            *)
                ARGS+=("$1")
                ;;
        esac
        shift
    done
    
    # Set default emerge args if none provided
    if [[ ${#emerge_args[@]} -eq 0 ]]; then
        emerge_args=("--ask")
    fi
    
    SearchInput="${ARGS[*]}"
    
    # Store selected packages for automatic retry
    local last_selected_packages=()
    local auto_retry=false
    
    # Main package management loop
    while true; do
        local PICKS=()
        
        # If we're in auto-retry mode, skip FZF and use last selected packages
        if [[ "$auto_retry" == "true" && ${#last_selected_packages[@]} -gt 0 ]]; then
            echo "🔄 Auto-retrying installation with previously selected packages..."
            PKGS=("${last_selected_packages[@]}")
            auto_retry=false
        else
            # Normal FZF selection
            __emerge_list "$SearchInput" | fzf \
                --bind "ctrl-r:execute:${EMERGE_CMD} -aC \$(echo {1} | cut -d':' -f1)" \
                --bind "ctrl-w:execute:${PRIV_ESC} emaint sync -a && ${EMERGE_CMD} -avuDN @world" \
                --bind "ctrl-z:execute:${EMERGE_CMD} -1 @preserved-rebuild" \
                --bind "ctrl-s:execute:${PRIV_ESC} emaint sync -a" \
                --bind "ctrl-o:execute:${BASH_SOURCE[0]} -c" \
                --bind 'ctrl-/:change-preview-window(up,border-rounded|up,40%,border-rounded|left,border-rounded|left,border-rounded,40%|down,border-rounded|down,40%,border-rounded|down,10%,border-rounded|hidden|right,40%,border-rounded|right,70%,border-rounded|right,90%,border-rounded)' \
                --bind 'ctrl-l:clear-query+clear-screen+clear-selection' \
                --bind 'alt-bspace:clear-query' \
                --bind 'alt-left:kill-word' \
                --bind "esc:abort" \
                --bind 'ctrl-q:abort' \
                --bind 'ctrl-d:deselect-all' \
                --bind 'ctrl-i:select-all' \
                --bind 'ctrl-v:toggle-preview' \
                --bind 'ctrl-n:next-history' \
                --bind 'ctrl-b:previous-history' \
                --bind 'right:first' \
                --bind 'left:last' \
                --bind 'end:first' \
                --bind 'home:last' \
                --bind 'pgdn:page-down' \
                --bind 'pgup:page-up' \
                --bind 'shift-tab:deselect' \
                --bind 'tab:select' \
                --bind "?:preview(echo '$(_pwrfzf_keys)')" \
                --bind "change:first" \
                --header 'Press ? for keybindings | Ctrl+o: Config | Ctrl+s: Sync | Ctrl+z: Preserved' \
                --header-lines=1 \
                --preview-window "$PWRFZF_PREVIEW_WINDOW" \
                --history="$PWRFZF_HISTORY" \
                --query="${SearchInput}" \
                --preview-label-pos=top \
                --border-label-pos=3 \
                --border 'double' \
                --preview-label="╣${SearchInput:-pwrfzf}╠" \
                --border-label="┨${PROG}┠" \
                --info=inline \
                --scroll-off=20 \
                --hscroll-off=30 \
                --ellipsis="⣿" \
                --tiebreak=begin \
                --sync \
                --multi \
                --delimiter ' ' \
                --ansi \
                --color="${pwrfzf_colortheme}" \
                --preview="bash -c '\"${BASH_SOURCE[0]}\" __fzf_preview {1}'" | while read -r line; do
                    PICKS+=("$line")
                done
            
            if [[ ${#PICKS[@]} -eq 0 ]]; then
                exit 0
            fi
            
            declare -a PKGS
            for PICK in "${PICKS[@]}"; do
                if [[ "$PICK" =~ ^([^:]+) ]]; then
                    PKGS+=("${BASH_REMATCH[1]}")
                fi
            done
            
            # Store the selected packages for potential auto-retry
            last_selected_packages=("${PKGS[@]}")
        fi
        
        if [[ ${PWRFZF_CONFIRM_ACTIONS} == "true" ]]; then
            echo "══════════════════════════════════════"
            echo "CONFIRM INSTALLATION:"
            echo "Selected packages: ${PKGS[*]}"
            echo "Execute: ${EMERGE_CMD} ${emerge_args[*]} ${PKGS[*]}"
            echo ""
            echo "Proceed with installation? (y/N)"
            read -r answer
            if [[ "$answer" =~ ^[Yy]$ ]]; then
                _install_packages_with_fallback "${emerge_args[@]}" "${PKGS[@]}"
                local install_result=$?
                if [[ $install_result -eq 2 ]]; then
                    echo "🔄 Configuration updated. Auto-retrying installation..."
                    auto_retry=true
                    # Continue to next loop iteration which will auto-retry
                    continue
                elif [[ $install_result -eq 130 ]]; then
                    echo "⏹️ Installation cancelled by user"
                    # Don't auto-retry, just continue to next selection
                    continue
                fi
            else
                echo "⚠️ Installation cancelled"
            fi
        else
            _install_packages_with_fallback "${emerge_args[@]}" "${PKGS[@]}"
            local install_result=$?
            if [[ $install_result -eq 2 ]]; then
                echo "🔄 Configuration updated. Auto-retrying installation..."
                auto_retry=true
                # Continue to next loop iteration which will auto-retry
                continue
            elif [[ $install_result -eq 130 ]]; then
                echo "⏹️ Installation cancelled by user"
                # Don't auto-retry, just continue to next selection
                continue
            fi
        fi

        # Reset auto_retry flag for next selection
        auto_retry=false
    done
}

# Main script execution
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    case "${1:-}" in
        _config_preview)
            _config_preview "$2"
            exit 0
            ;;
        _action_preview)
            _action_preview "$2" "$3"
            exit 0
            ;;
        _sets_action_preview)
            _sets_action_preview "$2"
            exit 0
            ;;
        __fzf_preview)
            __fzf_preview "$2"
            exit 0
            ;;
    esac

    # Only initialize and run main if we're the main script execution
    _pwrfzf_init
    main "$@"
fi
